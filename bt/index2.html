<!DOCTYPE htmle>
<html>
	<head>
		<title></title>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta http-equiv="content-type" content="text/html" charset="utf-8">
		<meta name="description" content="">
		<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0">
		<link href="../reset.css" rel="stylesheet" />
		<link href="../layout.css" rel="stylesheet" />
		<script src="../CanvasCommon.js"></script>
		<script src="../Shape.js"></script>
		<script src="../Sprite.js"></script>
	</head>
	<body>
		<article><canvas id="canvas" width='640' height='480'></canvas></article>
	</body>
</html>
<script>

var g_prevTime=0;
function guidGen() {
   var now = new Date().getTime();
   if(now <= g_prevTime) now = g_prevTime + 1; g_prevTime = now;
   var num = (now-new Date('2013/1/1').getTime())+''+Math.random().toString().substr(2,4);
   return Number(num).toString(36);
};

var x_distance=(v0,a,t)=>{return {vt:v0+a*t,s:v0*t+0.5*a*t*t}};
var getDistance=(vx,vy,ax,ay,t)=>{return {vxt:vx+ax*t,vyt:vy+ay*t,sx:vx*t+0.5*ax*t*t,sy:vy*t+0.5*ay*t*t}};
var x_vt=(v0,a,t)=>v0+a*t;
var x_ds=(v0,a,t)=>v0*t+a*t*t/2;

var canvas = G('canvas');
var cxt = canvas.getContext('2d');
var W = canvas.width;
var H = canvas.height;

function newLine(x1,y1,x2,y2,dx,dy,flag){
	var line = new Line();
	line.addPoint(x1,y1);
	line.addPoint(x2,y2);
	line.dx = dx;
	line.dy = dy;
	line.flag=flag;
	return line;
}

//墙
var walls = [
	newLine(0,0,W,0,1,-1,1),
	newLine(0,0,0,H,-1,1,1),
	newLine(W,0,W,H,-1,1,-1),
	newLine(0,H,W,H,1,-1,-1)
];
walls.forEach(function(wall){ wall.pp=wall.getPP(W/2,H/2); });
//小球
var sps = [];

function move(sprite,context,now){
	if(sprite.stop) return;
	var self = sprite, vx=self.velocityX, vy=self.velocityY, ax=self.accx, ay=self.accy;
		self.preTime = self.preTime || 0;
	if(self.preTime){
		var t=(now-self.preTime)/1000,
			dObj = getDistance(vx,vy,ax,ay,t);
		var orgx = self.left;
		var orgy = self.top;
		self.left+=dObj.sx;
		self.top+=dObj.sy;
		self.velocityX=dObj.vxt;
		self.velocityY=dObj.vyt;
		if(self.getVelocity()<200){
			self.velocityX=0;
			self.velocityY=0;
			sprite.stop = true;
		}
		walls.forEach(function(wall){
			if(wall.collidesWith(self.shape) || wall.getPP(self.left,self.top)*wall.pp<0){
				//保证是靠近的才算，解决短时间内两次碰撞的问题
				//if(wall.getPointDistance(orgx,orgy)>wall.getPointDistance(self.left,self.top)){
				//}
				//10毫秒内不允许两次碰撞
				//if(!self.preCollidesTime || (now-self.preCollidesTime)>100){
				//}
				//self.preCollidesTime = now;
				if(wall.dx<0){
					self.velocityX=-self.velocityX;
					self.accx =(self.velocityX>0?-1:1)*Math.abs(self.accx);
					self.left=wall.points[0].x+wall.flag*self.shape.radius;
				}
				if(wall.dy<0){
					self.velocityY=-self.velocityY;
					self.accy =(self.velocityY>0?-1:1)*Math.abs(self.accy);
					self.top=wall.points[0].y+wall.flag*self.shape.radius;
				}
			}
		});
	}
	self.preTime = now;
}

function Bool(name){
	this.accx = 0;
	this.accy = 0;
	this.sprite = new Sprite(name);
	var self = this;
	this.sprite.painter={
		paint:function(sprite,context){
			self.updateShape();
			context.save();
			sprite.shape.createPath(context);
			context.fillStyle=sprite.shape.fillStyle;
			context.strokeStyle=sprite.shape.strokeStyle;
			context.fill();
			context.stroke();
			context.restore();
		}
	}
	this.sprite.behaviors=[{execute:move}];
	this.sprite.shape = new Circle();
	this.sprite.guid=guidGen();
}

Bool.prototype.updateShape=function(){
	var shape = this.sprite.shape;
	shape.radius=this.sprite.width/2;
	shape.x=this.sprite.left;
	shape.y=this.sprite.top;
}

Bool.prototype.update=function(left,top,width,height,velocityx,velocityy,ax,ay){
	var shape = this.sprite;
	shape.left=left;
	shape.top=top;
	shape.width=width;
	shape.height=height;
	shape.velocityX=velocityx;
	shape.velocityY=velocityy;
	shape.accx=ax;
	shape.accy=ay;
}

Sprite.prototype.getVelocity=function(){
	return this.velocityX*this.velocityX+this.velocityY*this.velocityY;
}
Sprite.prototype.updateShape = function(){
	with(this.shape){
		radius=this.width/2;
		x=this.left;
		y=this.top;
	}
}

function renum(x,y){
	return x*y>0?-y:y;
}

function getK(vx,vy){
	return Math.abs(vx)/(Math.abs(vx)+ Math.abs(vy));
}

function getAcc(vx,vy,a){
	var Vx=Math.abs(vx),
		Vy=Math.abs(vy),
		V=Vx+Vy,
		kx=vx*a>0?-a:a,
		ky=vy*a>0?-a:a;
	return { ax:(Vx/V)*kx, ay:(Vy/V)*ky }
}

function createBoll(x,y,r,vx,vy,a){
	var bool=new Bool('Boll');
	var obj=getAcc(vx,vy,a);
	//left,top,width,height,velocityx,velocityy,ax,ay
	bool.update(x,y,r,r,vx,vy,obj.ax,obj.ay);
	return bool;
}

/*
	createBoll(W/2,H/2,20,100,-100,10.6),
	createBoll(W/2,H/2,20,100,100,10.6),
	createBoll(W/2,H/2,20,-100,-100,10.6),
	createBoll(W/2,H/2,20,-100,100,10.6)
*/

sps = [
	createBoll(W/2,H/2+50,20,-200,-40,20),
	createBoll(W/2,H/2-50,20,-200,40,20)
];

function collidesBool(){
	var b1,b2,cbs=[];
	for(var i=0,il=sps.length-1;i<il;i++){
		b1=sps[i].sprite;
		sps[i].updateShape();
		for(var j=i+1;j<sps.length;j++){
			sps[j].updateShape();
			b2=sps[j].sprite;
			if(b1.shape.collidesWith(b2.shape)){
				cbs.push([b1,b2]);
				var tx=b1.velocityX,ty=b1.velocityY;
				b1.velocityX=b2.velocityX;
				b1.velocityY=b2.velocityY;
				b2.velocityX=tx;
				b2.velocityY=ty;
			}
		}
	}
}

function draw(){
	//cxt.clearRect(0,0,W,H);
	sps.forEach(function(bool){
		bool.sprite.print(cxt);
		bool.sprite.update(cxt,+new Date);
	});
	collidesBool();
	requestAnimationFrame(draw);
}

requestAnimationFrame(draw);

</script>
